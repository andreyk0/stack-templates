{-# START_FILE .gitignore #-}
/{{name}}.cabal
/.sources
/.stack-work
/target
{-# START_FILE Makefile #-}
TARGET=target
EXE=$(TARGET)/{{name}}
DIST_EXE=$(EXE)-$(shell uname -s)-$(shell uname -m)
DIST_EXE_SIG=$(DIST_EXE).sig

build:
	stack build $(STACK_OPTS) {{name}}
	hlint src app

build-prof:
	stack build $(STACK_OPTS) --profile --ghc-options="-rtsopts -fprof-auto" {{name}}

install:
	stack install $(STACK_OPTS) {{name}}

bindist:
	mkdir -p $(TARGET)
	stack --local-bin-path $(TARGET) install $(STACK_OPTS) {{name}}
	upx --best $(EXE)
	mv $(EXE) $(DIST_EXE)
	gpg --output $(DIST_EXE_SIG) --detach-sign $(DIST_EXE)

clean:
	stack clean
	rm -rf $(TARGET)

.PHONY: build build-prof clean
{-# START_FILE bin/{{name}} #-}
#!/bin/bash
exec stack exec {{name}} -- "$@"
{-# START_FILE package.yaml #-}
name: {{name}}
version: '0.1.0.0'
synopsis: Initial project template from stack
description: Please see README.md
category: {{category}}{{^category}}Web{{/category}}
author: {{author-name}}{{^author-name}}Author name here{{/author-name}}
maintainer: {{author-email}}{{^author-email}}example@example.com{{/author-email}}
copyright: {{copyright}}{{^copyright}}{{year}}{{^year}}2018{{/year}} {{author-name}}{{^author-name}}Author name here{{/author-name}}{{/copyright}}
license: BSD3
homepage: https://github.com/{{github-username}}{{^github-username}}githubuser{{/github-username}}/{{name}}#readme

default-extensions:
  - BangPatterns
  - DataKinds
  - DefaultSignatures
  - DeriveDataTypeable
  - GeneralizedNewtypeDeriving
  - LambdaCase
  - OverloadedLabels
  - OverloadedLists
  - OverloadedStrings
  - PartialTypeSignatures
  - PatternSynonyms
  - QuasiQuotes
  - RecordWildCards
  - ScopedTypeVariables
  - TemplateHaskell
  - TypeApplications
  - TypeOperators
  - ViewPatterns

dependencies:
  - aeson
  - base
  - bytestring
  - conduit
  - conduit-extra
  - containers
  - exceptions
  - gitrev
  - monad-control
  - monad-logger
  - monad-loops
  - mtl
  - optparse-applicative
  - text
  - transformers
  - transformers-base
  - unliftio
  - unliftio-core
  - utf8-string

library:
  source-dirs: src
  ghc-options:
    - -Wall

executables:
  {{name}}:
    main: Main.hs
    source-dirs: app
    dependencies:
      - {{name}}
    ghc-options:
      - -O2
      - -Wall
      - -rtsopts
      - -threaded
      - -with-rtsopts=-N
{-# START_FILE .hlint.yaml #-}
# HLint configuration file
# https://github.com/ndmitchell/hlint
##########################

# This file contains a template configuration file, which is typically
# placed as .hlint.yaml in the root of your project


# Specify additional command line arguments
#
# - arguments: [--color, --cpp-simple, -XQuasiQuotes]

 - arguments: [-XQuasiQuotes]

# Control which extensions/flags/modules/functions can be used
#
# - extensions:
#   - default: false # all extension are banned by default
#   - name: [PatternGuards, ViewPatterns] # only these listed extensions can be used
#   - {name: CPP, within: CrossPlatform} # CPP can only be used in a given module
#
# - flags:
#   - {name: -w, within: []} # -w is allowed nowhere
#
# - modules:
#   - {name: [Data.Set, Data.HashSet], as: Set} # if you import Data.Set qualified, it must be as 'Set'
#   - {name: Control.Arrow, within: []} # Certain modules are banned entirely
#
# - functions:
#   - {name: unsafePerformIO, within: []} # unsafePerformIO can only appear in no modules


# Add custom hints for this project
#
# Will suggest replacing "wibbleMany [myvar]" with "wibbleOne myvar"
# - error: {lhs: "wibbleMany [x]", rhs: wibbleOne x}


# Turn on hints that are off by default
#
# Ban "module X(module X) where", to require a real export list
# - warn: {name: Use explicit module export list}
#
# Replace a $ b $ c with a . b $ c
# - group: {name: dollar, enabled: true}
#
# Generalise map to fmap, ++ to <>
# - group: {name: generalise, enabled: true}


# Ignore some builtin hints
# - ignore: {name: Use let}
# - ignore: {name: Use const, within: SpecialModule} # Only within certain modules

# e.g. askUnliftIO generates an unnecessary warning
# - ignore: { name: "Use <$>", within: App }

# Define some custom infix operators
# - fixity: infixr 3 ~^#^~


# To generate a suitable file for HLint do:
# $ hlint --default > .hlint.yaml
{-# START_FILE .stylish-haskell.yaml #-}
# stylish-haskell configuration file
# ==================================

# The stylish-haskell tool is mainly configured by specifying steps. These steps
# are a list, so they have an order, and one specific step may appear more than
# once (if needed). Each file is processed by these steps in the given order.
steps:
  # Convert some ASCII sequences to their Unicode equivalents. This is disabled
  # by default.
  # - unicode_syntax:
  #     # In order to make this work, we also need to insert the UnicodeSyntax
  #     # language pragma. If this flag is set to true, we insert it when it's
  #     # not already present. You may want to disable it if you configure
  #     # language extensions using some other method than pragmas. Default:
  #     # true.
  #     add_language_pragma: true

  # Align the right hand side of some elements.  This is quite conservative
  # and only applies to statements where each element occupies a single
  # line.
  - simple_align:
      cases: true
      top_level_patterns: true
      records: true

  # Import cleanup
  - imports:
      # There are different ways we can align names and lists.
      #
      # - global: Align the import names and import list throughout the entire
      #   file.
      #
      # - file: Like global, but don't add padding when there are no qualified
      #   imports in the file.
      #
      # - group: Only align the imports per group (a group is formed by adjacent
      #   import lines).
      #
      # - none: Do not perform any alignment.
      #
      # Default: global.
      align: file

      # The following options affect only import list alignment.
      #
      # List align has following options:
      #
      # - after_alias: Import list is aligned with end of import including
      #   'as' and 'hiding' keywords.
      #
      #   > import qualified Data.List      as List (concat, foldl, foldr, head,
      #   >                                          init, last, length)
      #
      # - with_alias: Import list is aligned with start of alias or hiding.
      #
      #   > import qualified Data.List      as List (concat, foldl, foldr, head,
      #   >                                 init, last, length)
      #
      # - new_line: Import list starts always on new line.
      #
      #   > import qualified Data.List      as List
      #   >     (concat, foldl, foldr, head, init, last, length)
      #
      # Default: after_alias
      list_align: after_alias

      # Right-pad the module names to align imports in a group:
      #
      # - true: a little more readable
      #
      #   > import qualified Data.List       as List (concat, foldl, foldr,
      #   >                                           init, last, length)
      #   > import qualified Data.List.Extra as List (concat, foldl, foldr,
      #   >                                           init, last, length)
      #
      # - false: diff-safe
      #
      #   > import qualified Data.List as List (concat, foldl, foldr, init,
      #   >                                     last, length)
      #   > import qualified Data.List.Extra as List (concat, foldl, foldr,
      #   >                                           init, last, length)
      #
      # Default: true
      pad_module_names: false

      # Long list align style takes effect when import is too long. This is
      # determined by 'columns' setting.
      #
      # - inline: This option will put as much specs on same line as possible.
      #
      # - new_line: Import list will start on new line.
      #
      # - new_line_multiline: Import list will start on new line when it's
      #   short enough to fit to single line. Otherwise it'll be multiline.
      #
      # - multiline: One line per import list entry.
      #   Type with constructor list acts like single import.
      #
      #   > import qualified Data.Map as M
      #   >     ( empty
      #   >     , singleton
      #   >     , ...
      #   >     , delete
      #   >     )
      #
      # Default: inline
      long_list_align: inline

      # Align empty list (importing instances)
      #
      # Empty list align has following options
      #
      # - inherit: inherit list_align setting
      #
      # - right_after: () is right after the module name:
      #
      #   > import Vector.Instances ()
      #
      # Default: inherit
      empty_list_align: inherit

      # List padding determines indentation of import list on lines after import.
      # This option affects 'long_list_align'.
      #
      # - <integer>: constant value
      #
      # - module_name: align under start of module name.
      #   Useful for 'file' and 'group' align settings.
      list_padding: 4

      # Separate lists option affects formatting of import list for type
      # or class. The only difference is single space between type and list
      # of constructors, selectors and class functions.
      #
      # - true: There is single space between Foldable type and list of it's
      #   functions.
      #
      #   > import Data.Foldable (Foldable (fold, foldl, foldMap))
      #
      # - false: There is no space between Foldable type and list of it's
      #   functions.
      #
      #   > import Data.Foldable (Foldable(fold, foldl, foldMap))
      #
      # Default: true
      separate_lists: true

      # Space surround option affects formatting of import lists on a single
      # line. The only difference is single space after the initial
      # parenthesis and a single space before the terminal parenthesis.
      #
      # - true: There is single space associated with the enclosing
      #   parenthesis.
      #
      #   > import Data.Foo ( foo )
      #
      # - false: There is no space associated with the enclosing parenthesis
      #
      #   > import Data.Foo (foo)
      #
      # Default: false
      space_surround: false

  # Language pragmas
  - language_pragmas:
      # We can generate different styles of language pragma lists.
      #
      # - vertical: Vertical-spaced language pragmas, one per line.
      #
      # - compact: A more compact style.
      #
      # - compact_line: Similar to compact, but wrap each line with
      #   `{-#LANGUAGE #-}'.
      #
      # Default: vertical.
      style: vertical

      # Align affects alignment of closing pragma brackets.
      #
      # - true: Brackets are aligned in same column.
      #
      # - false: Brackets are not aligned together. There is only one space
      #   between actual import and closing bracket.
      #
      # Default: true
      align: true

      # stylish-haskell can detect redundancy of some language pragmas. If this
      # is set to true, it will remove those redundant pragmas. Default: true.
      remove_redundant: true

  # Replace tabs by spaces. This is disabled by default.
  # - tabs:
  #     # Number of spaces to use for each tab. Default: 8, as specified by the
  #     # Haskell report.
  #     spaces: 8

  # Remove trailing whitespace
  - trailing_whitespace: {}

  # Squash multiple spaces between the left and right hand sides of some
  # elements into single spaces. Basically, this undoes the effect of
  # simple_align but is a bit less conservative.
  # - squash: {}

# A common setting is the number of columns (parts of) code will be wrapped
# to. Different steps take this into account. Default: 80.
columns: 80

# By default, line endings are converted according to the OS. You can override
# preferred format here.
#
# - native: Native newline format. CRLF on Windows, LF on other OSes.
#
# - lf: Convert to LF ("\n").
#
# - crlf: Convert to CRLF ("\r\n").
#
# Default: native.
newline: native

# Sometimes, language extensions are specified in a cabal file or from the
# command line instead of using language pragmas in the file. stylish-haskell
# needs to be aware of these, so it can parse the file correctly.
#
# No language extensions are enabled by default.
language_extensions:
  - BangPatterns
  - DataKinds
  - DefaultSignatures
  - DeriveDataTypeable
  - GeneralizedNewtypeDeriving
  - LambdaCase
  - OverloadedLabels
  - OverloadedLists
  - OverloadedStrings
  - PartialTypeSignatures
  - PatternSynonyms
  - QuasiQuotes
  - RecordWildCards
  - ScopedTypeVariables
  - TemplateHaskell
  - TypeApplications
  - TypeOperators
  - ViewPatterns
{-# START_FILE Setup.hs #-}
import Distribution.Simple
main = defaultMain
{-# START_FILE app/Args.hs #-}
module Args
  (
    Args(..)
  , parseCliArgs
  ) where

import Development.GitRev
import Options.Applicative

data Custom = Custom1 | Custom2 deriving (Eq, Show, Ord)


data Args = Args { argsVerbose :: !Bool
                 , argsUser    :: !String
                 , argsHost    :: !String
                 , argsCustom  :: !Custom
                 } deriving (Show)


parseArgs :: Parser Args
parseArgs = Args
     <$> switch
         ( long "verbose"
        <> short 'v'
        <> help "Be verbose.")
     <*> strOption
         ( long "user"
        <> short 'u'
        <> help "App user" )
     <*> strOption
         ( long "host"
        <> short 'h'
        <> value "localhost"
        <> showDefault
        <> help "App host" )
     <*> option parseCustomArg
         ( long "custom-arg"
        <> short 'c'
        <> value Custom1
        <> showDefault
        <> help "Arg with a custom parser." )


parseCustomArg :: ReadM Custom
parseCustomArg = eitherReader $ \case
    "c1" -> Right Custom1
    "c2" -> Right Custom2
    x    -> Left $ "Failed to parse custom argument " <> x <> ", expected 'c1' or 'c2'"


parseCliArgs :: IO Args
parseCliArgs = execParser opts
  where
    opts = info (helper <*> parseArgs)
      ( fullDesc
     <> header ("Add program header here. " <> "Version: " <> $(gitBranch) <> "@" <> $(gitHash))
     <> progDesc "Add program description here. Source: https://github.com/{{github-username}}{{^github-username}}githubuser{{/github-username}}/{{name}}")
{-# START_FILE app/App.hs #-}
module App
  (
    App
  , getArgs
  , isVerbose
  , runApp
  ) where


import           Args
import           Control.Monad.Catch
import           Control.Monad.IO.Unlift
import           Control.Monad.Logger
import           Control.Monad.Reader


data AppState = AppState
  { asArgs :: !Args
    -- more state
  }


newtype App a = App
  { unApp :: ReaderT AppState (LoggingT IO) a
  } deriving ( Applicative
             , Functor
             , Monad
             , MonadCatch
             , MonadIO
             , MonadLogger
             , MonadLoggerIO
             , MonadReader AppState
             , MonadThrow
             , MonadUnliftIO
             )


isVerbose :: App Bool
isVerbose = fmap argsVerbose getArgs


getArgs :: App Args
getArgs = asks asArgs


runApp :: App a
       -> IO a
runApp appA  = do
  args@Args{..} <- parseCliArgs

  let llf _ ll = argsVerbose || ll >= LevelInfo
  runStderrLoggingT $ filterLogger llf $ runReaderT (unApp appA) (AppState args)
{-# START_FILE app/Main.hs #-}
module Main where

import App
import Args
import Control.Monad.IO.Class
import Control.Monad.Logger


main:: IO ()
main = runApp $ do
  args@Args{..} <- getArgs
  liftIO $ print args
  $(logInfoSH) args
{-# START_FILE src/Util.hs #-}
module Util
  (
    askUser
  , withTerminalEcho
  ) where


import           Control.Monad.Catch
import           Control.Monad.IO.Class
import           Data.Text (Text)
import qualified Data.Text.IO as TIO
import           System.IO


-- | Control terminal echo, flush stdin, for user interaction
withTerminalEcho :: Bool -- ^ echo user input to terminal
                 -> IO a -- ^ IO action
                 -> IO a
withTerminalEcho echo action = do
  hFlush stdout
  old <- hGetEcho stdin
  bracket_ (hSetEcho stdin echo)
           (do hSetEcho stdin old ; hFlush stdout)
           action


-- | Prompt user for input
askUser :: (MonadIO m)
        => Text -- ^ user prompt
        -> m Text
askUser prompt = liftIO $ do
  TIO.putStr prompt
  hFlush stdout
  x <- TIO.getLine
  TIO.putStrLn ""
  hFlush stdout
  pure x
{-# START_FILE LICENSE #-}
Copyright {{author-name}}{{^author-name}}Author name here{{/author-name}} (c) {{year}}{{^year}}2016{{/year}}

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of {{author-name}}{{^author-name}}Author name here{{/author-name}} nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{-# START_FILE README.md #-}
# {{name}}
